问题：假设有一个字符串集合，每一个字符串都是数字字符串，求一个合法的排列组合，使得得到的组合字符串的数字值最小。
如{"312","3","321"},最小的字符串排列组合为3123213

算法：采用贪心策略。
排列字符串的数字位数必然是固定的，等于集合中所有字符串的长度之和。
因为要使最终字符串代表的数字值最小，所以每次查找必然优先考虑首字符最小的字符串，因此查找的过程中需将集合中的字符串按照首字符分类得到若干个子集。
每个子集寻找一个最小的字符串排列组合。
对于每个子集，因为字符串的长度长短不一，需要对短字符串进行补齐到子集中的最长长度。补齐方法为遍历一次子集，确定子集k位前缀的最小值，k的范围为1到字符串的最长长度。对于需要补齐的字符串拼接对应的最小值。
补齐以后再遍历一次子集，找到最小的值，去掉补齐的值，添加到最终结果末尾，并将这个值从子集中去除。
重复子集的查找，直到这个子集为空。
如果所有子集都被搜索过了，那么得到的最终结果就是最终答案。

时间复杂度分析：
对于每个子集，补齐操作需要遍历一次，并求出k前缀最小值，时间复杂度为O(kn)，补齐后查找子集找到最小的元素的时间复杂度为O(kn)
假设一个子集的元素的平均长度为k,那么上述的操作每次最少找到1位的数字，那么需要进行上述的操作至多kn次，总时间复杂度为O(k^2n^2)
所以最终的算法时间复杂度为O(n^2).
